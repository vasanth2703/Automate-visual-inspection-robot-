<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AMR 3D Visualizer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: hidden;
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #canvas3d {
            width: 100%;
            height: 100%;
        }
        .controls-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            min-width: 280px;
            max-width: 320px;
        }
        .controls-panel h2 {
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
            font-weight: 600;
        }
        .btn {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 8px;
        }
        .btn-primary { background: #667eea; color: white; }
        .btn-primary:hover { background: #5568d3; }
        .btn-secondary { background: #48bb78; color: white; }
        .btn-secondary:hover { background: #38a169; }
        .btn:disabled { background: #ccc; cursor: not-allowed; }
        .status-display {
            background: #f7fafc;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            color: #333;
            margin-top: 10px;
        }
        .status-display .label { color: #666; font-weight: 600; }
        .status-display .value { color: #2d3748; }
        .info-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            font-size: 12px;
            color: #333;
        }
        .info-panel h3 { margin-bottom: 10px; font-size: 14px; }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-right: 8px;
        }
        input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }
        select, input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas3d"></canvas>
        
        <div class="controls-panel">
            <h2>ðŸ¤– AMR Control Panel</h2>
            
            <div class="control-group">
                <label>AMR Position (X)</label>
                <input type="range" id="amrXSlider" min="0" max="2" step="0.1" value="0">
                <span id="amrXValue">0.0 m</span>
            </div>
            
            <div class="control-group">
                <label>Lift Height</label>
                <input type="range" id="heightSlider" min="0.3" max="2.3" step="0.1" value="0.3">
                <span id="heightValue">0.3 m</span>
            </div>
            
            <div class="control-group">
                <label>Camera Mode</label>
                <select id="cameraMode">
                    <option value="crop">Crop Mode</option>
                    <option value="random">Random Mode</option>
                </select>
            </div>
            
            <button class="btn btn-primary" id="startScanBtn">Start Scan</button>
            <button class="btn btn-secondary" id="resetBtn">Reset Position</button>
            
            <div class="status-display">
                <div><span class="label">Status:</span> <span class="value" id="statusText">Ready</span></div>
                <div><span class="label">Height:</span> <span class="value" id="currentHeight">0.3 m</span></div>
                <div><span class="label">Progress:</span> <span class="value" id="progressText">0%</span></div>
            </div>
        </div>
        
        <div class="info-panel">
            <h3>Legend</h3>
            <div class="legend-item">
                <div class="legend-color" style="background: #4299e1;"></div>
                <span>AMR Base</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #48bb78;"></div>
                <span>Vertical Lift</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ed8936;"></div>
                <span>Camera Bracket</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #9f7aea;"></div>
                <span>Cameras (3x)</span>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Three.js Scene Setup
        let scene, camera, renderer, amrGroup, liftGroup, bracketGroup, cameras3D = [];
        let animationId = null;
        let isScanning = false;
        let scanHeights = [0.3, 0.6, 0.9, 1.2, 1.5, 1.8, 2.1, 2.3];
        let currentScanIndex = 0;
        
        const API_BASE = 'http://localhost:8000';
        
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a202c);
            scene.fog = new THREE.Fog(0x1a202c, 10, 50);
            
            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 3, 5);
            camera.lookAt(0, 1, 0);
            
            // Renderer
            const canvas = document.getElementById('canvas3d');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            const pointLight = new THREE.PointLight(0x4299e1, 0.5);
            pointLight.position.set(-3, 2, -3);
            scene.add(pointLight);
            
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(20, 20);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2d3748,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Grid
            const gridHelper = new THREE.GridHelper(20, 20, 0x4a5568, 0x2d3748);
            scene.add(gridHelper);
            
            // Wall (inspection target)
            const wallGeometry = new THREE.BoxGeometry(4, 3, 0.2);
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x718096,
                roughness: 0.7
            });
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.set(0, 1.5, -2);
            wall.receiveShadow = true;
            scene.add(wall);
            
            // Create AMR Robot
            createAMR();
            
            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById('amrXSlider').addEventListener('input', updateAMRPosition);
            document.getElementById('heightSlider').addEventListener('input', updateLiftHeight);
            document.getElementById('startScanBtn').addEventListener('click', startScan);
            document.getElementById('resetBtn').addEventListener('click', resetPosition);
            
            // Animation Loop
            animate();
        }
        
        function createAMR() {
            // AMR Base Group
            amrGroup = new THREE.Group();
            
            // Base Platform
            const baseGeometry = new THREE.BoxGeometry(1, 0.2, 0.8);
            const baseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4299e1,
                metalness: 0.6,
                roughness: 0.4
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.castShadow = true;
            base.receiveShadow = true;
            amrGroup.add(base);
            
            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.05, 16);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x2d3748 });
            
            const wheelPositions = [
                [-0.4, -0.1, 0.3], [0.4, -0.1, 0.3],
                [-0.4, -0.1, -0.3], [0.4, -0.1, -0.3]
            ];
            
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(...pos);
                wheel.castShadow = true;
                amrGroup.add(wheel);
            });
            
            // Vertical Lift Group
            liftGroup = new THREE.Group();
            liftGroup.position.y = 0.1;
            
            // Lift Column
            const columnGeometry = new THREE.BoxGeometry(0.15, 2.5, 0.15);
            const columnMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x48bb78,
                metalness: 0.7,
                roughness: 0.3
            });
            const column = new THREE.Mesh(columnGeometry, columnMaterial);
            column.position.y = 1.25;
            column.castShadow = true;
            liftGroup.add(column);
            
            // Camera Bracket Group
            bracketGroup = new THREE.Group();
            bracketGroup.position.y = 0.3;
            
            // Bracket Arm
            const armGeometry = new THREE.BoxGeometry(1.2, 0.1, 0.3);
            const armMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xed8936,
                metalness: 0.5,
                roughness: 0.5
            });
            const arm = new THREE.Mesh(armGeometry, armMaterial);
            arm.castShadow = true;
            bracketGroup.add(arm);
            
            // 3 Cameras
            const cameraGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.2);
            const cameraMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x9f7aea,
                metalness: 0.8,
                roughness: 0.2
            });
            
            const cameraPositions = [-0.4, 0, 0.4]; // Left, Center, Right
            cameraPositions.forEach((xPos, idx) => {
                const cam = new THREE.Mesh(cameraGeometry, cameraMaterial);
                cam.position.set(xPos, -0.15, 0.2);
                cam.castShadow = true;
                
                // Camera lens (glowing effect)
                const lensGeometry = new THREE.CircleGeometry(0.05, 16);
                const lensMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.8
                });
                const lens = new THREE.Mesh(lensGeometry, lensMaterial);
                lens.position.z = 0.11;
                cam.add(lens);
                
                bracketGroup.add(cam);
                cameras3D.push(cam);
            });
            
            liftGroup.add(bracketGroup);
            amrGroup.add(liftGroup);
            
            amrGroup.position.set(0, 0.1, 0);
            scene.add(amrGroup);
        }
        
        function updateAMRPosition(e) {
            const x = parseFloat(e.target.value);
            amrGroup.position.x = x;
            document.getElementById('amrXValue').textContent = x.toFixed(1) + ' m';
        }
        
        function updateLiftHeight(e) {
            const height = parseFloat(e.target.value);
            bracketGroup.position.y = height;
            document.getElementById('heightValue').textContent = height.toFixed(1) + ' m';
            document.getElementById('currentHeight').textContent = height.toFixed(1) + ' m';
        }
        
        function resetPosition() {
            amrGroup.position.x = 0;
            bracketGroup.position.y = 0.3;
            document.getElementById('amrXSlider').value = 0;
            document.getElementById('heightSlider').value = 0.3;
            document.getElementById('amrXValue').textContent = '0.0 m';
            document.getElementById('heightValue').textContent = '0.3 m';
            document.getElementById('currentHeight').textContent = '0.3 m';
            updateStatus('Reset to initial position');
        }
        
        async function startScan() {
            if (isScanning) return;
            
            isScanning = true;
            currentScanIndex = 0;
            document.getElementById('startScanBtn').disabled = true;
            updateStatus('Starting scan...');
            
            const amrX = parseFloat(document.getElementById('amrXSlider').value);
            const cameraMode = document.getElementById('cameraMode').value;
            
            // Start backend scan
            try {
                await fetch(`${API_BASE}/scan/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ amr_x: amrX, camera_mode: cameraMode })
                });
            } catch (error) {
                console.log('Backend not available, running visual simulation only');
            }
            
            // Animate scan
            animateScan();
        }
        
        function animateScan() {
            if (currentScanIndex >= scanHeights.length) {
                isScanning = false;
                document.getElementById('startScanBtn').disabled = false;
                updateStatus('Scan complete!');
                document.getElementById('progressText').textContent = '100%';
                return;
            }
            
            const targetHeight = scanHeights[currentScanIndex];
            const currentHeight = bracketGroup.position.y;
            
            updateStatus(`Moving to height ${targetHeight.toFixed(1)}m`);
            
            // Animate lift movement
            animateLiftTo(targetHeight, () => {
                updateStatus('Stabilizing...');
                flashCameras();
                
                setTimeout(() => {
                    updateStatus('Capturing images...');
                    setTimeout(() => {
                        updateStatus('Running AI detection...');
                        const progress = ((currentScanIndex + 1) / scanHeights.length * 100).toFixed(0);
                        document.getElementById('progressText').textContent = progress + '%';
                        
                        currentScanIndex++;
                        setTimeout(animateScan, 500);
                    }, 300);
                }, 300);
            });
        }
        
        function animateLiftTo(targetHeight, callback) {
            const startHeight = bracketGroup.position.y;
            const duration = 500;
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing function
                const eased = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                bracketGroup.position.y = startHeight + (targetHeight - startHeight) * eased;
                document.getElementById('heightSlider').value = bracketGroup.position.y;
                document.getElementById('heightValue').textContent = bracketGroup.position.y.toFixed(1) + ' m';
                document.getElementById('currentHeight').textContent = bracketGroup.position.y.toFixed(1) + ' m';
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    callback();
                }
            }
            
            animate();
        }
        
        function flashCameras() {
            cameras3D.forEach((cam, idx) => {
                setTimeout(() => {
                    const lens = cam.children[0];
                    lens.material.opacity = 1;
                    lens.material.emissive = new THREE.Color(0x00ffff);
                    lens.material.emissiveIntensity = 2;
                    
                    setTimeout(() => {
                        lens.material.opacity = 0.8;
                        lens.material.emissiveIntensity = 0;
                    }, 100);
                }, idx * 100);
            });
        }
        
        function updateStatus(message) {
            document.getElementById('statusText').textContent = message;
        }
        
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            // Rotate camera around scene
            const time = Date.now() * 0.0001;
            camera.position.x = Math.cos(time) * 5;
            camera.position.z = Math.sin(time) * 5;
            camera.lookAt(0, 1.2, 0);
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Initialize
        init();
    </script>
</body>
</html>
